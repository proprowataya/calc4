function getSimpleAdditionCode(){return"// Define your custom operator\n// to add the given integers\nD[myadd|x, y|x + y]\n\n// Let's use it\n12{myadd}23"}function getHelloWorldCode(){return"// The 'P' operator prints the given operand as a character\n// to the console. The value of the 'P' operator itself is zero.\n// The following code outputs \"Hello world!\".\n72P101P108P108P111P32P119P111P114P108P100P33P10P"}
function getFibonacciCode(){return"D[fib|n|n <= 1 ? n ? (n-1){fib} + (n-2){fib}] 20{fib}"}
function getPrintPrimesCode(){return"/********************************\n *\n * Print prime numbers up to 100\n *\n ********************************/\n\n// This program shows prime numbers up to the next value\n// - Change the value as needed\nD[MaxN||100]\n\n// An operator to determine whether the given integer is prime or not.\n// - The 'isPrimeImpl' operator recursively calls itself to process the next value.\n// - The 'isPrime' operator wraps it.\nD[isPrimeImpl|n, i|i * i > n ?\n                   1 ? (\n                   n % i == 0 ?\n                   0 ?\n                   n {isPrimeImpl} (i + 1))]\nD[isPrime|n|n {isPrimeImpl} 2]\n\n// Operators to print the given integer\nD[or|x,y|x == 0 ? (y == 0 ? 0 ? 1) ? 1]\nD[printIntImpl|n, divisor, printZero|({divisor} != 0) ?\n                                     (/* Print one digit */\n                                      ((((n / {divisor})S != 0) {or} {printZero}) ? ((48 + L)P) ? 0)\n                                      /* Recursive call to process next digit */\n                                      ((n % {divisor}){printIntImpl}({divisor} / 10){printIntImpl}({printZero}{or}(L != 0)))) ?\n                                     0]\nD[printInt|n|n == 0 ?\n             48P ?  // Special case when the operand is zero\n             n{printIntImpl}1000000000000000000{printIntImpl}0]\n\n/**** Core part of the program *****/\nD[printPrimes|i|i > {MaxN} ?\n                0 ?\n                (/* If 'i' is prime, we print it */\n                 (i{isPrime} ? ((i{printInt})(10P)) ? 0)\n                 /* Recursive call to process the next value */\n                 ((i + 1){printPrimes}))]\n\n// Start program\n(2{printPrimes})\n(10P)   // New line at the end"}
function getFizzBuzzCode(){return'/************************************\n *\n * FizzBuzz program written in Calc4\n *\n ************************************/\n\n// This program shows numbers up to the next value\n// - Change the value as needed\nD[MaxN||100]\n\n// Operators to print "Fizz", "Buzz", or "Fizzbuzz".\n// See the "Hello World" sample code to understand how this works.\nD[printFizzbuzz||70P105P122P122P98P117P122P122P10P]\nD[printFizz||70P105P122P122P10P]\nD[printBuzz||66P117P122P122P10P]\n\n// Operators to print the given integer\nD[or|x,y|x == 0 ? (y == 0 ? 0 ? 1) ? 1]\nD[printIntImpl|n, divisor, printZero|({divisor} != 0) ?\n                                     (/* Print one digit */\n                                      ((((n / {divisor})S != 0) {or} {printZero}) ? ((48 + L)P) ? 0)\n                                      /* Recursive call to process next digit */\n                                      ((n % {divisor}){printIntImpl}({divisor} / 10){printIntImpl}({printZero}{or}(L != 0)))) ?\n                                     0]\nD[printInt|n|n == 0 ?\n             48P ?  // Special case when the operand is zero\n             n{printIntImpl}1000000000000000000{printIntImpl}0]\n\n/**** Core part of the program *****/\nD[fizzbuzz|i|i <= {MaxN} ?\n             (/* Print current number */\n              (i % 15 == 0 ?\n               {printFizzbuzz} ? (\n               i % 3 == 0 ?\n               {printFizz} ? (\n               i % 5 == 0 ?\n               {printBuzz} ?\n               (i{printInt}10P))))\n              /* Recursive call to process the next value */\n              ((i + 1){fizzbuzz})) ?\n             0]\n\n(1{fizzbuzz})\n(10P)'}
function getMandelbrotSetCode(){return"/***************************************************************\n *\n * Mandelbrot Set Program Written in Calc4\n *\n * This program displays the Mandelbrot set to the console.\n * Use an integer of size 64 bits or larger to run the program.\n *\n ***************************************************************/\n\n/*****\n * Definitions of constants\n * - In Calc4, we use zero-operand operators as constant values\n *****/\n\n// Operators for fixed-point numbers\n// - Calc4 does not support floating points, instead only integer types are available.\n//   We represent real numbers as fixed-point numbers.\n//   The following operators help fixed-point arithmetic.\n//   For example, the calculation of \"2 / 3\" can be written as follows:\n//      (2{toFixed}) {div} (3{toFixed})\nD[Shift||65536]             // We multiply this value to represent an integer as fixed-point number\nD[toFixed|x|x * {Shift}]    // Convert the given integer to the fixed-point number\nD[add|x,y|x + y]\nD[sub|x,y|x - y]\nD[mult|x,y|x * y / {Shift}]\nD[div|x,y|x * {Shift} / y]\n\n// The area in the complex plane where we will compute the Mandelbrot set\nD[MinX||(0 - 2){toFixed}]\nD[MaxX||1{toFixed}]\nD[MinY||(0 - 1){toFixed}]\nD[MaxY||1{toFixed}]\n\n// Width of the console to display\n// - If you wish to get high-definition image, please increase these values.\nD[CanvasWidthX||110]\nD[CanvasWidthY||25]\n\n// If the square of the absolute value exceeds this value, we judge it to be divergent.\nD[Inf||4{toFixed}]\n\n// The maximum number of iterations for each point\nD[LoopLimit||1000]\n\n/*****\n * Helpers\n *****/\nD[getMax|x,y|x > y ? x ? y]\nD[newline||10P]\n\n/*****\n *\n * Computation of the Mandelbrot set\n *\n * The Mandelbrot set computation can be expressed like the following pseudocode.\n *\n * for (var i = 0; i < CanvasWidthX; i++) {\n *     for (var j = 0; j < CanvasWidthY; j++) {\n *         // For each point, determine if it diverges\n *         for (var loop = 0; loop < LoopLimit; loop++) {\n *             if (x * x + y * y > Inf) {\n *                 do something when divergence;\n *                 break;\n *             }\n *\n *             update current status and continue;\n *         }\n *     }\n * }\n *\n * However, Calc4 does not have loops, so we use recursive operators.\n * First, we extract the loop on i to an operator.\n *\n * operator computeX(i) {\n *     if (i < CanvasWidthX) {\n *         // The content of the loop will be done in the computeY operator\n *         computeY(i, 0, a);\n *\n *         // Utilize the tail recursion to repeat iterations\n *         return computeX(i + 1);\n *     }\n *\n *     // End of the loop\n *     return 0;\n * }\n *\n * operator computeY(i, j, a) {\n *     for (var j = 0; j < CanvasWidthY; j++) {\n *         ...\n *     }\n * }\n *\n * We perform the same transformations on the inner loops in computeY.\n *\n *****/\n\n// We store the number of iterations until each point diverges in the memory.\n// The following operator computes the destination index in the memory.\nD[getIndex|i,j|i * ({CanvasWidthX}{getMax}{CanvasWidthY}) + j]\n\n// The operator to store the number of iterations in the memory\nD[setPoint|i,j,loop|{loop}->(i{getIndex}j)]\n\n// The 'index' operand is the value in [0, CanvasWidthXorY).\n// This operator converts the value to the coordinate in the complex plane.\nD[getCoordinate|index,min,max,canvasWidth|({index}{toFixed}) {mult} ({max}{sub}{min}) {div} ({canvasWidth}{toFixed}) {add} {min}]\n\n/***** Core part of the computation *****/\nD[computePoint|loop,x,y,a,b,i,j|((x{mult}x){add}(y{mult}y)) > {Inf} ?\n                                (i{setPoint}j{setPoint}{loop}) ? (\n                                ({loop} >= {LoopLimit}) ?\n                                0 ?\n                                (({loop} + 1)\n                                    {computePoint}\n                                 ((x{mult}x) {sub} (y{mult}y) {add} a)\n                                    {computePoint}\n                                 (2{toFixed} {mult} x {mult} y {add} b)\n                                    {computePoint}\n                                 a\n                                    {computePoint}\n                                 b\n                                    {computePoint}\n                                 i\n                                    {computePoint}\n                                 j))]\nD[computeY|i,j,a|j < {CanvasWidthY} ?\n                 ((i{setPoint}j{setPoint}{LoopLimit})\n                  (0\n                    {computePoint}\n                   0\n                    {computePoint}\n                   0\n                    {computePoint}\n                   a\n                    {computePoint}\n                   (j{getCoordinate}{MinY}{getCoordinate}{MaxY}{getCoordinate}{CanvasWidthY})\n                    {computePoint}\n                   i\n                    {computePoint}\n                   j)\n                  (i{computeY}(j + 1){computeY}a)) ?\n                 0]\nD[computeX|i|i < {CanvasWidthX} ?\n             ((i\n                {computeY}\n               0\n                {computeY}\n               (i{getCoordinate}{MinX}\n                    {getCoordinate}\n                {MaxX}\n                    {getCoordinate}\n                {CanvasWidthX}))\n              ((i + 1){computeX})) ?\n             0]\n\n/*****\n * Output the result to the console\n *****/\n\n// Print the computed result\nD[printPoint|v|(v != {LoopLimit} ? 64 ? 32)P]\nD[printX|i, j|i < {CanvasWidthX} ? (((i{getIndex}j)@{printPoint})((i+1){printX}j)) ? (10P)]\nD[printY|j|j < {CanvasWidthY} ? ((0{printX}j)((j+1){printY})) ? 0]\n\n/*****\n * We have completed the definitions of the required operators.\n * Start the program by calling them.\n *****/\n(0{computeX})\n(0{printY})"};
